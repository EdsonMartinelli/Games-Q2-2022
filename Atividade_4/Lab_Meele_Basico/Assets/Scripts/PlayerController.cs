using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerController : MonoBehaviour
{

    Animator anim; // Armazena o controlador da animação.
    bool isWalkingFlag;   // Armazena os estado do parâmetro "isWalking".
    bool isRunningFlag;   // Armazena os estado do parâmetro "isRunning".
    bool isAttackingFlag;  // Armazena os estado do parâmetro "isAttacking".

    PlayerControls input; // Armazena as informacoes do controlador do player.

    Vector2 movimento = new Vector2(); // Armazena os controles de direção.
    bool movimentoPressionado; // armazena o estado de mover.
    bool runPressionado; // armazena os estado de correr.

    public float suavizarRotacao = 0; // Armazena um valor para suavizar a rotação.

    /* O método Awake é chamado quando uma instância com esse script for criada
     * (executada antes do metodo Start.
     */
    private void Awake()
    {
        input = new PlayerControls();

        /* performed é uma função de evento que é disparada toda vez que uma
         * determinado estado é registrado. No caso da perfomed, o evento é
         * disparado sempre que uma action é completada.
         * 
         * Para gerenciar tal evento a classe possui uma variável de evento 
         * (pode ser identificada através da palavra reservada event) que pode
         * ser atribuida através da subscrita do operador += (sobrecarga de 
         * operadores da linguaguem C#). Dessa forma, assim que performed for
         * chamada, o método passado pelo operador também será chamado.
         * 
         */
        input.Player.Move.performed += ctx =>
        {

            // Armazena o movimento em um vetor 2D.
            movimento = ctx.ReadValue<Vector2>();
            /* Verfica se o movimento é 0 em ambos os eixos. A linha foi comentada
             * pois alterei algumas coisas que deixaram a movimentação mais fluida.
             */
            // movimentoPressionado = movimento.x != 0 || movimento.y != 0; 

            /* Coloca o movimentoPressionado como true para que Move funcione
             * corretamente.
             */
            movimentoPressionado = true;
        };


        /* canceled é um evento similar ao performed, mas é disparado quando a action
         * é cancelada. Foi adicionado por mim para gerar mais fluidez.
         */
        input.Player.Move.canceled += ctx =>
        {
            // Quando a ação é cancelada, o movimento é setado para false.
            movimentoPressionado = false;
        };

        // Mesma descrição do comando a cima.
        input.Player.Run.performed += ctx =>
        {
            // Verifica se o botão está apertado ou não.
            runPressionado = ctx.ReadValueAsButton();
        };

        // Mesma descrição do comando a cima.
        input.Player.Attack.performed += ctx =>
        {
            // Verifica se o botão está apertado ou não.
            isAttackingFlag = true;
            anim.SetBool("isAttacking", isAttackingFlag);
        };

        // Mesma descrição do comando a cima.
        input.Player.Attack.canceled += ctx =>
        {
            // Termina a execução do ataque.
            isAttackingFlag = false;
            anim.SetBool("isAttacking", isAttackingFlag);
        };

    }

    // Método de controle de movimento.
    void Mover()
    {
        /* Coloca o parâmetro isWalking em true caso o movimento aconteça e
         * o isWalkingFlag esteja em false.
         */
        if (movimentoPressionado && !isWalkingFlag)
        {
            isWalkingFlag = true;
            anim.SetBool("isWalking", isWalkingFlag);
        }

        /* Coloca o parâmetro isWalking em false caso o movimento não aconteça 
         * e o isWalkingFlag esteja em true.
         */
        if (!movimentoPressionado && isWalkingFlag)
        {
            isWalkingFlag = false;
            anim.SetBool("isWalking", isWalkingFlag);
        }


        /* Coloca o parâmetro isRunning em true caso o movimento aconteça e o
         * botão de correr esteja pressionado aconteça e isRunningFlag seja 
         * false.
        */
        if ((movimentoPressionado && runPressionado) && !isRunningFlag)
        {
            isRunningFlag = true;
            anim.SetBool("isRunning", isRunningFlag);
        }

        /* O não haja movimento ou a tecla de correr não esteja pressionada e
         * isRunningFlag é true, coloca o parâmetro isRunningFlag em false.
         */
        if ((!movimentoPressionado || !runPressionado) && isRunningFlag)
        {
            isRunningFlag = false;
            anim.SetBool("isRunning", isRunningFlag);
        }
    }

    // Controle de rotação da instância.
    void Rotacionar()
    {
        // Pega a rotação atual.
        Quaternion atualPosicao = transform.rotation;

        // Pega o angulo dado pelo input em x e y.
        float angulo= Mathf.Atan2(movimento.x, movimento.y) * Mathf.Rad2Deg;

        /* Usa a função euler para criar uma rotação no eixo Y com o angulo dado
         * por x e y do input.
         */
        Quaternion novaPosicao = Quaternion.Euler(0f, Mathf.Round(angulo), 0f);

        /* Usa Lerp para criar uma rotação interpolada. Com isso, apenas parte do
         * movimento é feito, assim permitindo uma suavição da rotação (E forçando
         * o jogador a apertar por mais tempo o botão desejado para virar).
         */
        Quaternion x = Quaternion.Lerp(atualPosicao, novaPosicao, Time.deltaTime * suavizarRotacao);

        // Coloca a rotação obtida como rotação do objeto.
        transform.rotation = x;

    }

    // Start is called before the first frame update
    void Start()
    {
        // Pega o componente de animação da instância.
        anim = GetComponent<Animator>();

        // Inicializa parâmetros.
        anim.SetBool("isWalking", isWalkingFlag);
        anim.SetBool("isRunning", isRunningFlag);
    }

    // Update is called once per frame
    void Update()
    {
        Mover();
        Rotacionar();
    }


    // Habilita input.
    public void OnEnable()
    {
        input.Player.Enable();
    }


    // Desabilita input.
    public void OnDisable()
    {
        input.Player.Disable();
    }
}
